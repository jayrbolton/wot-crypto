const assert = require('assert')
const sodium = require('sodium-universal')

// Throughout this lib we commonly use these two abbreviations
// - pk: public key
// - sk: secret key
//
// In crypto_box, pk is used for encrypting, and sk is used for decrypting
// In crypto_sign, sk is used for signing, and pk is used for verifying
//
// All functions take and return strings for everything, and they zero out all buffers

var crypto = module.exports = {}

// Generate a simple random hex string of some length
crypto.id = function id (length) {
  assert(length > 0)
  const buf = sodium.malloc(length)
  sodium.randombytes_buf(buf)
  const str = buf.toString('hex')
  buf.fill(0)
  return str
}

// Generate a secret key from a password -- asynchronous
// callback gets an object of {salt, secret}
// You'll need the salt later to regenerate the same secret key from the same passhprase
// The salt doesn't need to be private
crypto.hashPass = function hashPass (pass, salt, callback) {
  assert(pass && pass.length > 0 && typeof pass === 'string', 'pass in a string passphrase')
  assert.strictEqual(typeof callback, 'function', 'pass in a callback function')

  const secret = sodium.malloc(32) // equal to crypto_box_SEEDBYTES and crypto_sign_SEEDBYTES
  const passBuf = Buffer.from(pass, 'utf8')
  if (!salt) {
    salt = sodium.malloc(sodium.crypto_pwhash_SALTBYTES)
    sodium.randombytes_buf(salt)
  } else {
    salt = Buffer.from(salt, 'hex')
  }
  sodium.crypto_pwhash_async(
    secret,
    passBuf,
    salt,
    sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE, // ops limit
    sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE, // mem limit
    sodium.crypto_pwhash_ALG_DEFAULT, // algorithm
    function (err) {
      if (err) return callback(err)
      const saltStr = salt.toString('hex')
      const secretStr = secret.toString('hex')
      salt.fill(0)
      secret.fill(0)
      passBuf.fill(0)
      callback(null, {salt: saltStr, secret: secretStr})
    }
  )
}

// Encrypt plaintext using a secret key -- symmetric encryption -- synchronous
// Returns hex string of nonce and cipher separated by linebreak -- nonce is on first line
crypto.encrypt = function encrypt (secret, message) {
  assert(secret && secret.length > 0, 'pass in a secret key')
  assert(message && message.length > 0, 'pass in a plaintext message')
  secret = Buffer.from(secret, 'utf8')
  message = Buffer.from(message, 'utf8')
  const cipher = sodium.malloc(message.length + sodium.crypto_secretbox_MACBYTES)
  const nonce = sodium.malloc(sodium.crypto_secretbox_NONCEBYTES)
  sodium.randombytes_buf(nonce)
  sodium.crypto_secretbox_easy(cipher, message, nonce, secret)
  const resultStr = nonce.toString('hex') + '\n' + cipher.toString('hex')
  secret.fill(0)
  message.fill(0)
  nonce.fill(0)
  cipher.fill(0)
  return resultStr
}

// Decrypt some encrypted data generated by crypto.encrypt (crypto_secretbox) -- symmetric encryption -- synchronous
// Returns the plaintext unencrypted buffer
crypto.decrypt = function decrypt (secret, encrypted) {
  assert(secret && secret.length > 0, 'pass in a secret key')
  assert.strictEqual(typeof encrypted, 'string', 'pass in the encrypted message as a hex string')
  secret = Buffer.from(secret, 'utf8')
  const [nonce, cipher] = encrypted.split('\n').map(str => Buffer.from(str, 'hex'))
  assert(nonce && nonce.length > 0, 'invalid encrypted string -- no nonce')
  assert(cipher && cipher.length > 0, 'invalid encrypted string -- no cipher')
  const plaintext = sodium.malloc(cipher.length - sodium.crypto_secretbox_MACBYTES)
  const result = sodium.crypto_secretbox_open_easy(plaintext, cipher, nonce, secret)
  if (!result) throw new Error('Unable to decrypt')
  const resultStr = plaintext.toString('utf8')
  nonce.fill(0)
  cipher.fill(0)
  secret.fill(0)
  plaintext.fill(0)
  return resultStr
}

// Create a public/secret key pair that can be used for signing messages (crypto_sign)
// Returns an object of {pk, sk} with each being buffers of the keys
crypto.createSignKeypair = function signKeyPair (seed) {
  assert(seed && seed.length, 'pass in a seed buffer of length 32')
  const seedBuf = Buffer.from(seed, 'hex')
  const pk = sodium.malloc(sodium.crypto_sign_PUBLICKEYBYTES)
  const sk = sodium.malloc(sodium.crypto_sign_SECRETKEYBYTES)
  sodium.crypto_sign_seed_keypair(pk, sk, seedBuf)
  const pkStr = pk.toString('hex')
  const skStr = sk.toString('hex')
  seedBuf.fill(0)
  pk.fill(0)
  sk.fill(0)
  return {pk: pkStr, sk: skStr}
}

// Create a public/secret key pair that can be used for enrypting messages (crypto_box)
// Returns an object of {pk, sk} with each being buffers of the keys
crypto.createBoxKeypair = function boxKeyPair (seed) {
  assert(seed && seed.length, 'pass in a seed buffer of length 32')
  const seedBuf = Buffer.from(seed, 'hex')
  const pk = sodium.malloc(sodium.crypto_box_PUBLICKEYBYTES)
  const sk = sodium.malloc(sodium.crypto_box_SECRETKEYBYTES)
  sodium.crypto_box_seed_keypair(pk, sk, seedBuf)
  const pkStr = pk.toString('hex')
  const skStr = sk.toString('hex')
  seedBuf.fill(0)
  pk.fill(0)
  sk.fill(0)
  seedBuf.fill(0)
  return {pk: pkStr, sk: skStr}
}

// Sign a message using a signing sk (with crypto_sign)
crypto.sign = function sign (message, sk) {
  const messageBuf = Buffer.from(message, 'utf8')
  const skBuf = Buffer.from(sk, 'hex')
  const signed = sodium.malloc(messageBuf.length + sodium.crypto_sign_BYTES)
  sodium.crypto_sign(signed, messageBuf, skBuf)
  const signedStr = signed.toString('hex')
  signed.fill(0)
  messageBuf.fill(0)
  skBuf.fill(0)
  return signedStr
}

// Open a signed message using a crypto_sign public key
crypto.openSigned = function openSigned (signed, pk) {
  const signedBuf = Buffer.from(signed, 'hex')
  const pkBuf = Buffer.from(pk, 'hex')
  const unsigned = sodium.malloc(signedBuf.length - sodium.crypto_sign_BYTES)
  const result = sodium.crypto_sign_open(unsigned, signedBuf, pkBuf)
  const unsignedStr = unsigned.toString('utf8')
  unsigned.fill(0)
  signedBuf.fill(0)
  pkBuf.fill(0)
  if (!result) throw Error('Invalid signature')
  return unsignedStr
}

// Encrypt a plaintext message using the sender's secret key and the receiver's public key
// crypto_box handles signing and verifying the sig, so you don't need to worry about signing before doing this
crypto.createBox = function createBox (message, pk, sk) {
  assert(pk && pk.length, 'pass in a public key')
  assert(message && message.length, 'pass in a message string')
  const messageBuf = Buffer.from(message, 'utf8')
  const pkBuf = Buffer.from(pk, 'hex')
  const skBuf = Buffer.from(sk, 'hex')
  const cipher = sodium.malloc(messageBuf.length + sodium.crypto_box_MACBYTES)
  const nonce = sodium.malloc(sodium.crypto_box_NONCEBYTES)
  sodium.randombytes_buf(nonce)
  sodium.crypto_box_easy(cipher, messageBuf, nonce, pkBuf, skBuf)
  const resultStr = nonce.toString('hex') + '\n' + cipher.toString('hex')
  cipher.fill(0)
  nonce.fill(0)
  pkBuf.fill(0)
  skBuf.fill(0)
  messageBuf.fill(0)
  return resultStr
}

// Decrypt and validate an encrypted message using the receiver's secret key and the sender's public key
crypto.openBox = function openBox (encrypted, pk, sk) {
  assert(encrypted && encrypted.length && typeof encrypted === 'string', 'pass in an encrypted string')
  const pkBuf = Buffer.from(pk, 'hex')
  const skBuf = Buffer.from(sk, 'hex')
  const [nonce, cipher] = encrypted.split('\n').map(str => Buffer.from(str, 'hex'))
  assert(nonce && nonce.length > 0, 'invalid encrypted string -- no nonce')
  assert(cipher && cipher.length > 0, 'invalid encrypted string -- no cipher')
  const message = sodium.malloc(cipher.length - sodium.crypto_box_MACBYTES)
  const result = sodium.crypto_box_open_easy(message, cipher, nonce, pkBuf, skBuf)
  const resultStr = message.toString('utf8')
  pkBuf.fill(0)
  skBuf.fill(0)
  nonce.fill(0)
  cipher.fill(0)
  message.fill(0)
  if (!result) throw new Error('Unable to decrypt message')
  return resultStr
}

// Hash a message
crypto.hash = function (message) {
  const hash = sodium.malloc(sodium.crypto_generichash_BYTES)
  const messageBuf = Buffer.from(message, 'utf8')
  sodium.crypto_generichash(hash, messageBuf)
  const hashStr = hash.toString('hex')
  hash.fill(0)
  messageBuf.fill(0)
  return hashStr
}

// Hash a message and sign it
crypto.hashAndSign = function (message, sk) {
  return crypto.sign(crypto.hash(message), sk)
}

// Verify the signature on the hash
// And verify the hash against the original message
crypto.unhashAndVerify = function unhashAndVerify (signedHash, message, pk) {
  const signedHashBuf = Buffer.from(signedHash, 'hex')
  const hash = crypto.hash(message)
  const unsignedHash = crypto.openSigned(signedHashBuf, pk)
  signedHashBuf.fill(0)
  if (hash !== unsignedHash) throw new Error("Given hash does not the message's hash")
  return unsignedHash
}
