const assert = require('assert')
const sodium = require('sodium-universal')

// Throughout this lib we commonly use these two abbreviations
// - pk: public key
// - sk: secret key
//
// In crypto_box, pk is used for encrypting, and sk is used for decrypting
// In crypto_sign, sk is used for signing, and pk is used for verifying

var crypto = module.exports = {}

// Generate a secret key from a password -- asynchronous
// callback gets an object of {salt, secret}
// You'll need the salt later to regenerate the same secret key from the same passhprase
// The salt doesn't need to be private
crypto.hashPass = function hashPass (pass, salt, callback) {
  assert(pass && pass.length > 0 && typeof pass === 'string', 'pass in a string passphrase')
  assert.strictEqual(typeof callback, 'function', 'pass in a callback function')

  const secret = sodium.malloc(32) // equal to crypto_box_SEEDBYTES and crypto_sign_SEEDBYTES
  if (!salt) {
    salt = sodium.malloc(sodium.crypto_pwhash_SALTBYTES)
    sodium.randombytes_buf(salt)
    // sodium.mlock(salt)
  }
  sodium.crypto_pwhash_async(
    secret,
    Buffer.from(pass),
    salt,
    sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE, // ops limit
    sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE, // mem limit
    sodium.crypto_pwhash_ALG_DEFAULT, // algorithm
    function (err) {
      if (err) return callback(err)
      callback(null, {salt, secret})
    }
  )
}

// Encrypt plaintext using a secret key -- asymmetric encryption -- synchronous
// Returns hex string of nonce and cipher separated by linebreak -- nonce is on first line
crypto.encrypt = function encrypt (secret, message) {
  assert(secret && secret.length > 0, 'pass in a secret key')
  assert(message && message.length > 0, 'pass in a plaintext message')
  secret = Buffer.from(secret)
  message = Buffer.from(message)
  const cipher = sodium.malloc(message.length + sodium.crypto_secretbox_MACBYTES)
  const nonce = sodium.malloc(sodium.crypto_secretbox_NONCEBYTES)
  sodium.randombytes_buf(nonce)
  sodium.crypto_secretbox_easy(cipher, message, nonce, secret)
  // sodium.mlock(cipher)
  // sodium.mlock(nonce)
  return nonce.toString('hex') + '\n' + cipher.toString('hex')
}

// Decrypt some encrypted data generated by crypto.encrypt (crypto_secretbox) -- asymmetric encryption -- synchronous
// Returns the plaintext unencrypted buffer
crypto.decrypt = function decrypt (secret, encrypted) {
  assert(secret && secret.length > 0, 'pass in a secret key')
  assert.strictEqual(typeof encrypted, 'string', 'pass in the encrypted message as a hex string')
  let [nonce, cipher] = encrypted.split('\n')
  assert(nonce && nonce.length > 0, 'invalid encrypted string -- no nonce')
  assert(cipher && cipher.length > 0, 'invalid encrypted string -- no cipher')
  nonce = Buffer.from(nonce, 'hex')
  cipher = Buffer.from(cipher, 'hex')
  secret = Buffer.from(secret)
  const plaintext = sodium.malloc(cipher.length - sodium.crypto_secretbox_MACBYTES)
  const result = sodium.crypto_secretbox_open_easy(plaintext, cipher, nonce, secret)
  // sodium.mlock(plaintext)
  if (!result) throw new Error('Unable to decrypt')
  return plaintext.toString('utf8')
}

// Create a public/secret key pair that can be used for signing messages (crypto_sign)
// Returns an object of {pk, sk} with each being buffers of the keys
crypto.createSignKeypair = function signKeyPair (seed) {
  assert(seed && seed.length, 'pass in a seed buffer of length 32')
  seed = Buffer.from(seed)
  const pk = sodium.malloc(sodium.crypto_sign_PUBLICKEYBYTES)
  const sk = sodium.malloc(sodium.crypto_sign_SECRETKEYBYTES)
  sodium.crypto_sign_seed_keypair(pk, sk, seed)
  // sodium.mlock(pk)
  // sodium.mlock(sk)
  return {pk, sk}
}

// Create a public/secret key pair that can be used for enrypting messages (crypto_box)
// Returns an object of {pk, sk} with each being buffers of the keys
crypto.createBoxKeypair = function boxKeyPair (seed) {
  assert(seed && seed.length, 'pass in a seed buffer of length 32')
  seed = Buffer.from(seed)
  const pk = sodium.malloc(sodium.crypto_box_PUBLICKEYBYTES)
  const sk = sodium.malloc(sodium.crypto_box_SECRETKEYBYTES)
  sodium.crypto_box_seed_keypair(pk, sk, seed)
  // sodium.mlock(pk)
  // sodium.mlock(sk)
  return {pk, sk}
}

// Sign a message using a signing sk (with crypto_sign)
crypto.sign = function sign (message, sk) {
  message = Buffer.from(message)
  const signed = sodium.malloc(message.length + sodium.crypto_sign_BYTES)
  sodium.crypto_sign(signed, message, sk)
  // sodium.mlock(signed)
  return signed
}

// Open a signed message using a crypto_sign public key
crypto.openSigned = function openSigned (signed, pk) {
  assert(signed && signed.length, 'pass in a signed message string of buffer')
  assert(pk && pk.length, 'pass in a public key for checking the signature')
  signed = Buffer.from(signed)
  const unsigned = sodium.malloc(signed.length - sodium.crypto_sign_BYTES)
  const result = sodium.crypto_sign_open(unsigned, signed, pk)
  // sodium.mlock(unsigned)
  if (!result) throw Error('Invalid signature')
  return unsigned.toString('utf8')
}

// Encrypt a plaintext message using the sender's secret key and the receiver's public key
// crypto_box handles signing and verifying the sig, so you don't need to worry about signing before doing this
crypto.createBox = function createBox (message, pk, sk) {
  assert(pk && pk.length, 'pass in a public key to encrypt with')
  assert(message && message.length, 'pass in a message string')
  message = Buffer.from(message)
  pk = Buffer.from(pk)
  sk = Buffer.from(sk)
  const cipher = sodium.malloc(message.length + sodium.crypto_box_MACBYTES)
  const nonce = sodium.malloc(sodium.crypto_box_NONCEBYTES)
  sodium.randombytes_buf(nonce)
  sodium.crypto_box_easy(cipher, message, nonce, pk, sk)
  // sodium.mlock(cipher)
  // sodium.mlock(nonce)
  return nonce.toString('hex') + '\n' + cipher.toString('hex')
}

// Decrypt and validate an encrypted message using the receiver's secret key and the sender's public key
crypto.openBox = function openBox (encrypted, pk, sk) {
  assert(encrypted && encrypted.length && typeof encrypted === 'string', 'pass in an encrypted string')
  pk = Buffer.from(pk)
  sk = Buffer.from(sk)
  const [nonce, cipher] = encrypted.split('\n').map(str => Buffer.from(str, 'hex'))
  assert(nonce && nonce.length > 0, 'invalid encrypted string -- no nonce')
  assert(cipher && cipher.length > 0, 'invalid encrypted string -- no cipher')
  const message = sodium.malloc(cipher.length - sodium.crypto_box_MACBYTES)
  const result = sodium.crypto_box_open_easy(message, cipher, nonce, pk, sk)
  // sodium.mlock(message)
  if (!result) throw new Error('Unable to decrypt message')
  return message.toString('utf8')
}
