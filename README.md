# wot-crypto

Utility wrapper around libsodium (via [sodium-universal](https://github.com/sodium-friends/sodium-universal)) for use in node-wot (PGP style encryption system for node)

```js
const crypto = require('wot-crypto')
```

## hashPass(pass, salt, callback)

Turn a plaintext passphrase into a 32-byte secret key that can be used for asymmetric encryption (see `encrypt` and `decrypt`)

`callback` receives arguments for `(err, secret, salt)`, where `secret` is a 32-byte buffer secret key generated from the passphrase>

`salt` can be null, which will cause a new random salt to be generated. You can also pass in a salt that you used before. If you pass in the same plaintext passhprase and the same salt, then you will get the same hash/secret.

```js
const pass = '123123123'
crypto.hashPass(pass, null, function (err, pwhash) {
  if (err) throw err
  pwhash.secret // -> 32-byte hashed secret
  pwhash.salt // -> 32-byte randomly generated salt
  // Regenerate the same secret using the same pass and salt
  crypto.hashpass(pass, pwhash.salt, function (err, pwhash2) {
    if (err) throw err
    t.strictEqual(pwhash2.secret, pwhash.secret)
    // Generate with a different salt, will produce a different hash
    crypto.hashpass(pass, fill(buffer.alloc(16), 'xyz'), function (err, pwhash3) {
      if (err) throw err
      t.notEqual(pwhash3.secret, pwhash2.secret)
      t.end()
    })
  })
})
```

## encrypt(secret, plainText)

Encrypt some plaintext using a secret key generated by `hashPass` above

```js
const pass = 'abcabcabc'
crypto.hashPass(pass, null, function (err, pwhash) {
  if (err) throw err
  const plain = 'hi there bub'
  const encrypted = crypto.encrypt(pwhash.secret, plain)
  const decrypted = crypto.decrypt(pwhash.secret, encrypted)
  t.strictEqual(decrypted, plain)
  t.end()
})
```

## decrypt(secret, encrypted)

Decrypt a string that was encrypted using the `encrypt` function above. `secret` should be a secret key generated by `hashPass`. `encrypted` should be an encrypted string returned by `encrypt`.

## createSignKeypair(seed)

Create a public key and secret key pair from a seed. The seed can be generated by `hashPass`.

This key pair can be used to sign messages and to validate existing signatures on signed messages.

```js
const {pk, sk} = crypto.createSignKeypair(secret)
```

## sign(message, secretKey)

Sign a message using a secret key generated by `createSignKeypair`.

```js
const {pk, sk} = crypto.createSignKeypair(fill(Buffer.alloc(32), 'xyz'))
const msg = 'hallo welt'
const signed = crypto.sign(msg, sk)
const unsigned = crypto.openSigned(signed, pk)
t.strictEqual(unsigned, msg)
```

## openSigned(signedMessage, publicKey)

Open a signed message and validate its signature. `signedMessage` should be the return value from `sign`. `publicKey` should be the public key generated by `createSignKeypair`.

See the code example under `sign`.

## createBoxKeypair(seed)

Create a public/secret key pair for sending encrypted messages to other users. The seed can be generated by `hashPass`.

```js
const {pk, sk} = crypto.createBoxKeypair(secret)
```

## createBox(message, receiverPublicKey, senderSecretKey)

Create a new encrypted message to send to another user. This takes care of signing the message as well.

Pass in the plain text message as the first argument.

Pass in the public key of the person who will receive the message. We use this public key to encrypt the message.

Pass in the secret key of the sender. This is used to sign the message.

All the keys should be generated by `createBoxKeypair`

See the code example under `openBox`

## openBox(encryptedMessage, senderPublicKey, receiverSecretKey)

Open an encrypted message that was created with `createBox`. This also takes care of validating the message signature of the sender.

Pass in a string encrypted message returned by `createBox`

Pass in the public key of the user who sent the message. This is for verifying the message's signature

Pass in the secret key of the user who is opening the message. This is for decrypting the message.

All the keys should be generated by `createBoxKeypair`

```js
const sender = crypto.createBoxKeypair(fill(Buffer.alloc(32), 'xyz'))
const receiver = crypto.createBoxKeypair(fill(Buffer.alloc(32), 'abc'))

const msg = 'hola mundo'
const encrypted = crypto.createBox(msg, receiver.pk, sender.sk)
const decrypted = crypto.openBox(encrypted, sender.pk, receiver.sk)

t.strictEqual(decrypted, msg)
```

